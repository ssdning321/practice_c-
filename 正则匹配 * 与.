//正则匹配'*'代表前方一个或多个字符，'.'代表任意字符 
bool isMatch(string s, string p) {
        int n=s.size(),m=p.size();
        vector<vector<bool>> dp(n+1,vector<bool>(m+1,false));//创建二维数组 初始化false
        dp[0][0]=true;//2个字符串都在0之前的位置时候（index==-1)，即都为空，匹配成功
        for(int j=1;j<m;j++){//当s字符串为空或者index==-1（即在0之前)的时候，p也可能匹配
            if(p[j]=='*'){
                dp[0][j+1]=dp[0][j-1];
            }
        }
        //for(int i=0;i<n;i++){}由于p为空时，除了s为空时，都不匹配dp[i][j]==false（i!=0）
        for(int j=0;j<m;j++){
            for(int i=0;i<n;i++){\\动态规划，对具体某一个s[i] p[j]进行分析
                if(s[i]==p[j]||p[j]=='.'){//满足此条件，即当前两个字符匹配，那么s[i] p[j]是否匹配取决于s[i-1] p[j-1]  (s[i]与p[j]之前的)是否匹配
                    dp[i+1][j+1] = dp[i-1+1][j-1+1];
                }//之前条件不匹配时候，还不能判false,p[j]为*的时候还可以抢救为true
                else if(p[j] == '*'){
                    if(s[i]==p[j-1] || p[j-1]=='.'){//当下一位匹配时，此时分三种情况讨论。*作用0次，1次，两次以上
                        dp[i+1][j+1] = dp[i+1][j-2+1] || dp[i-1+1][j-2+1] || dp[i-1+1][j+1];
                    }//
                    //1、*重复0次：即...b... 与...ba*...,此时a*忽略，dp[i][j]=dp[i][j-2]  即取决于...b与..b是否匹配
                    //2、重复1次：例如...ba...与...ba*...,此时*可忽略，dp[i][j]=dp[i-1][j-2] 即取决于...b与...b是否匹配
                    //3、重复2次及以上：例如...baaa...与...a*...,此时 dp[i][j]==dp[i-1][j]  即取决于...baa与...a*是否匹配
                    //只要一种为true,则是对应条件，当三者都为false时，dp[i][j]为false
                    else{
                        dp[i+1][j+1] = dp[i+1][j-2+1];\\不匹配，但是有*的存在，使得*作用于前方0次，s[i]，p[j]是否匹配取决于s[i]，p[j-2]  (忽略了char+'*')是否匹配
                    }
                }
                else{
                    //dp[i+1][j+1]=false;两个条件都不满足，字符不匹配又不是*，直接返回false
                }
            }
        }
        return dp[n][m];//对前方子串处理完，最后两个字符串是否匹配的最终结果
    }
